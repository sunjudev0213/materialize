[
    {
        "type": "Generic",
        "description": "Generic functions can typically take arguments of any type.",
        "functions": [
            {
                "signature": "CAST (cast_expr) -> T",
                "description": "Value as type `T`",
                "url": "cast"
            },
            {
                "signature": "coalesce(x: T...) -> T?",
                "description": "First non-_NULL_ arg, or _NULL_ if all are _NULL_"
            },
            {
                "signature": "nullif(x: T, y: T) -> T?",
                "description": "_NULL_ if `x == y`, else `x`"
            }
        ]
    },
    {
        "type": "Aggregate",
        "description": "Aggregate functions take one or more of the same element type as arguments.",
        "functions": [
            {
                "signature": "count(x: T) -> int",
                "description": "Number on non-_NULL_ inputs"
            },
            {
                "signature": "max(x: T) -> T",
                "description": "Maximum value among `T`"
            },
            {
                "signature": "min(x: T) -> T",
                "description": "Minimum value among `T`"
            },
            {
                "signature": "sum(x: T) -> T",
                "description": "Sum of `T`'s values"
            },
            {
                "signature": "stddev(x: T) -> T",
                "description": "Historical alias for `stddev_samp`\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            },
            {
                "signature": "stddev_pop(x: T) -> T",
                "description": "Population standard deviation of `T`'s values\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            },
            {
                "signature": "stddev_samp(x: T) -> T",
                "description": "Sample standard deviation of `T`'s values\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            },
            {
                "signature": "variance(x: T) -> T",
                "description": "Historical alias for `variance_samp`\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            },
            {
                "signature": "variance_pop(x: T) -> T",
                "description": "Population variance of `T`'s values\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            },
            {
                "signature": "variance_samp(x: T) -> T",
                "description": "Sample variance of `T`'s values\n\n*NUMERICALLY UNSTABLE: do not use if high accuracy is required.*"
            }
        ]
    },
    {
        "type": "Column",
        "description": "Column functions take column name arguments.",
        "functions": [
            {
                "signature": "lhs bool_op ALL(c: C) -> bool",
                "description": "`true` if applying [bool_op](#boolean) to `lhs` and every value of `C` evaluates to `true`"
            },
            {
                "signature": "lhs bool_op ANY(c: C) -> bool",
                "description": "`true` if applying [bool_op](#boolean) to `lhs` and any value of `C` evaluates to `true`"
            }
        ]
    },
    {
        "type": "Numbers",
        "description": "Number functions take number-like arguments, e.g. [`int`](../types/int), [`float`](../types/float), [`decimal`](../decimal).",
        "functions": [
            {
                "signature": "abs(x: N) -> N",
                "description": "The absolute value of `x`"
            },
            {
                "signature": "ceil(x: N) -> N",
                "description": "The largest integer >= `x`"
            },
            {
                "signature": "floor(x: N) -> N",
                "description": "The largest integer <= `x`"
            },
            {
                "signature": "mod(x: N, y: N) -> N",
                "description": "`x % y`"
            }
        ]
    },
    {
        "type": "String",
        "functions": [
            {
                "signature": "ascii(s: str) -> int",
                "description": "The ASCII value of `s`'s left-most character"
            },
            {
                "signature": "length(s: str) -> int",
                "description": "Number of graphemes in `s`",
                "url": "length"
            },
            {
                "signature": "length(s: str, encoding_name: str) -> int",
                "description": "Number of graphemes in `s` using `encoding_name`",
                "url": "length"
            },
            {
                "signature": "replace(s: str, f: str, r: str) -> str",
                "description": "`s` with all instances of `f` replaced with `r`"
            },
            {
                "signature": "substring(s: str, start_pos: int) -> str",
                "description": "Substring of `s` starting at `start_pos`",
                "url": "substring"
            },
            {
                "signature": "substring(s: str, start_pos: int, l: int) -> str",
                "description": "Substring starting at `start_pos` of length `l`",
                "url": "substring"
            }
        ]
    },
    {
        "type": "Time",
        "description": "Time functions take a time-like type, e.g. [`date`](../types/date), [`timestamp`](../types/timestamp), [`timestamptz`](../types/timestamptz).",
        "functions": [
            {
                "signature": "EXTRACT(extract_expr) -> float",
                "description": "Specified time component from value",
                "url": "extract"
            },
            {
                "signature": "now() -> timestamptz",
                "description": "The `timestamptz` representing the time at which this dataflow was created."
            }
        ]
    }
]
