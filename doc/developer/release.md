# Creating releases of the `materialized`

## Basic git workflow

The Materialize release process is based on an "always release master" philosophy, while
still allowing us to produce bugfix releases if they are urgently required.

There are three core git artifacts involved in every release:

* Every release is denoted by a git tag that specifically names that release.
* Before the release, there is a "release candidate" git tag that signifies that we are
  planning on making that commit the release.
* For each minor version `X.Y` there is a "release-X.Y" git branch that makes it easy to
  find the most recent release (by e.g. running `git describe release-X.Y`), so it is
  always:
  * the most recently-released git commit
  * work that is being staged for the next release

The goal is to keep it simple while still having high assurance that we are providing
excellent quality software to our users. In all the examples, the goal is 100% automation of everything that does not explicitly mention a human.

To start a new release version the steps look like:

1. A developer creates a new branch on the commit that you would like to be the next
   release, starting at `v0.1`:

        git checkout -b release-0.1 <A>

  which should cause the repo to look something like: ![created-branch](assets/release/01-create-branch.jpg)
1.
1. A developer creates and updates the tag and release branch with a tag that looks like
   `v<VERSION>-rc[<N>]`:

        git tag --annotated v0.1-rc <A>
        git push origin v0.1-rc
        git push origin release-0.1

1. More detailed testing takes place on the artifacts generated by this tag. For all
   tests materialized is not allowed to crash, and all quality of service measurements
   must never fall outside of our accepted bounds.

   The set of tests is:
   * Install apt/rpm packages in clean ubuntu/centos image, and the homebrew package is
     installed on a clean macos image
   * Full SLT (against auto-generated materialize/materialized image)
   * The chbench soak test is run for 72 hours (same docker image)
   * The protobuf soak test is run for 72 hours (same docker image)
1. A human verifies that everything looks good, tags and pushes the `v<VERSION>` tag --
   since there have been no problems, the release branch is up to date:

        git tag -a v0.1 v0.1-rc
        git push origin v0.1

   At this point the repo should look like, (ignoring the omitted `v0.1-rc` tag): ![created-tag](assets/release/02-tag.jpg)
1. make announcements and ðŸŽ‰ðŸ’ƒðŸ•º

## Fully elaborated git workflow

So far the release process only describes what happens when things go smoothly, and
releases are bug-free. But there are also several things that can happen that can cause
us to revisit old releases and pre-releases:

1. Testing can fail for reasons unrelated to the materialized codebase.
2. Testing can fail for reasons _related_ to the materialized codebase.
3. Bugs can be found post-release that are considered high-enough severity that we want
   to backport a bugfix.

Depending on the current level of automation, the solution for 1 is either to manually
re-run the tests, or to push a new tag. In the world where we have this fully automated
creating a new tag for `v0.1-rc` with an `N` suffix to kick off new tests _may_
look like:

    git tag -a v0.1-rc1 v0.1-rc
    git push origin v0.1-rc1

Alternatively, clicking through some CI interfaces to trigger long-running jobs will be
necessary.

No matter our level of automation, 2 & 3 have a very similar _solution_: push changes to
the `release-X.Y` branch, and eventually tag specific commits in a similar way to the
happy path.

Here is a walkthrough of a bad-case happening at every step in the release process:

1. Ensure that the repo is entirely up to date: `git pull origin`
1. Commit `A` in the master branch is tagged and the release branch is updated:

        git checkout --branch release-0.1 <A>
        git tag -a v0.1-rc <A>
        git push origin v0.1-rc
1. We release `v0.1`: `git tag -a v0.1 v0.1-rc`
1. A pair of issues are discovered that are deemed important enough for us to backport.
1. The fixes are tested and merged to `master` as commits `C` and `D`, after some
   unfortunately dangerous work has been commited to master (here as `B`). The repo
   therefore looks like this, and we do _not_ want to import `B` into the `release-0.1`
   branch: ![master-has-progressed](assets/release/03-master-has-progressed.jpg)
1. The commits on master are applied to the release branch:

        git checkout release-X.Y
        git cherry-pick C
        git cherry-pick D
1. That is tagged `git tag -a v0.1-rc1 HEAD`
1. Both the branch and the tag are pushed:

        git push origin release
        git push origin v0.1.1-rc
1. Long-running tests succeed again, the release is published to github and all
   distribution channels:

        git tag -a v0.1.1 v0.1.1-rc

   At this point the repo and successful releases looks like:
   ![release-bugfix](assets/release/04-tagged-release-11.jpg)
1. At this point we have gained confidence in commit `B`, so even though we don't have
   any features that we would like to market as `0.2` we would like to release bugfixes
   and improvements from mainline. That causes us to reset the `release-0.1` branch onto
   the commit that we would like to release:

        git checkout release-0.1
        git reset --hard <F>
        git tag -a v0.1.2-rc
        # run long-running tests
        git tag -a v0.1.2
        git push origin v0.1.2
        git push --force-with-lease release-0.1
   causing the repo to look like: ![updated](assets/release/05-update-11.jpg)
1. Later, we want to create a release that we believe is worthy of the `0.2` name,
   causing us to create a new `release-0.2` branch and do the various tag dances:

        git checkout --branch release-0.2 <H>
        git tag v0.2-rc
        git push origin v0.2-rc
        git push origin release-0.2
        # run long-running tests
        git tag v0.2
        git push origin v0.2

   causing our repo to look approximately like:
   ![two-releases](assets/release/06-two-releases.jpg)
