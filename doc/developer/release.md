# Creating releases of the `materialized`

## Basic git workflow

The Materialize release process is based on an "always release master" philosophy, while
still allowing us to produce bugfix releases if they are urgently required.

There are three core git artifacts involved in every release:

* Every release is denoted by a git tag that specifically names that release.
* Before the release, there is a "release candidate" git tag that signifies that we are
  planning on making that commit the release.
* There is a "release" git branch that just makes it easy to find the most recent
  release (by e.g. running `git describe release`), so it is always:
  * the most recently-released git commit
  * work that is being staged for the next release

The goal is to keep it simple while still having high assurance that we are providing
excellent quality software to our users. The exact steps -- with the goal of 100% automation of all steps that don't mention a human -- are:

1. A developer creates and updates the tag and release branch with a tag that looks like
   `v<VERSION>-rc[<N>]`:

        git tag --annotated v0.1-rc <COMMIT>
        git checkout release
        git merge v0.1-rc
        git push origin v0.1-rc
        git push origin release

1. More detailed testing takes place on the artifacts generated by this tag. For all
   tests materialized is not allowed to crash, and all quality of service measurements
   must never fall outside of our accepted bounds.

   The set of tests is:
   * Install apt/rpm packages in clean ubuntu/centos image, and the homebrew package is
     installed on a clean macos image
   * Full SLT (against auto-generated materialize/materialized image)
   * The chbench soak test is run for 72 hours (same docker image)
   * The protobuf soak test is run for 72 hours (same docker image)
1. A human verifies that everything looks good, tags and pushes the `v<VERSION>` tag --
   since there have been no problems, the release branch is up to date:

        git tag -a v0.1 v0.1-rc
        git push origin v0.1
1. make announcements and ðŸŽ‰ðŸ’ƒðŸ•º

## Fully elaborated git workflow

So far the release process only describes what happens when things go smoothly, and
releases are bug-free. But there are also several things that can happen that can cause
us to revisit old releases and pre-releases:

1. Testing can fail for reasons unrelated to the materialized codebase.
2. Testing can fail for reasons _related_ to the materialized codebase.
3. Bugs can be found post-release that are considered high-enough severity that we want
   to backport a bugfix.

Depending on the current level of automation, the solution for 1 is either to manually
re-run the tests, or to push a new tag. In the world where we have this fully automated
creating a new tag for `v0.1-prerelease` with an `N` suffix to kick off new tests _may_
look like:

    git tag -a v0.1-rc1 v0.1-rc
    git push origin v0.1-rc1

Alternatively, clicking through some CI interfaces to trigger long-running jobs will be
necessary.

No matter our level of automation, 2 & 3 have a very similar _solution_: push changes to
the `release` branch, and eventually tag specific commits in a similar way to the happy
path.

Here is a walkthrough of a bad-case happening at every step in the release process:

1. Ensure that the repo is entirely up to date: `git pull origin`
1. Commit `A` in the master branch is tagged and the release branch is updated:

        git tag -a v0.1-rc A
        git checkout release
        git merge v0.1-rc
        git push origin release
        git push origin v0.1-rc
1. Short tests run successfully, long tests are started
1. A memory leak is discovered in the long-running tests
1. The fix is tested and merged to `master` as commit `B`
1. The commit on master is applied to the release branch:

        git checkout release
        git cherry-pick B
1. That is tagged `git tag -a v0.1-rc1 HEAD`
1. Both the branch and the tag are pushed:

        git push origin release
        git push origin v0.1-rc1
1. Long-running tests succeed again, the release is published to github and all
   distribution channels:

        git tag -a v0.1 v0.1-rc1
1. Four days later a customer points out a security flaw, which we fix in `master` on
   commit `D`
1. The fix is deemed important enough for us to backport
1. We do the same dance as before, targeting a release version of `0.1.1`, but starting
   as a prerelease:

        git checkout release
        git cherry-pick D
        git tag -a v0.1.1-rc HEAD
        git push origin release
        git push origin v0.1.1-rc
1. If all tests pass we tag it as `v0.1.1` and do the public release process
